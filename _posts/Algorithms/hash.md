---
layout: single
title: "8. 해시"
---

[코딩 테스트 합격자 되기 - 파이썬편]를 참고하여 작성하였습니다.

## __해시__
###  1. 해시의 개념
  - 키에 해시 함수를 적용한 출력을 인덱스로 삼아 값을 저장하는 자료구조.
  - 키-값 일대일 대응으로 저장하므로 키를 통해 원하는 값에 바로 접근할 수 있음.
  - 아래 예시 그림에서 키 (key)는 사람의 이름이고 즉, 검색을 위한 정보이고 값 (value)는 찾고자 하는 정보인 전화번호임.
  - 키에 대응되는 값이 저장되어 있는 공간을 해시 테이블 (hash table)이라고 부르고, 해시 테이블의 각 데이터는 버킷 (bucket)이라고 부름. 
  
![해시 그림](https://github.com/user-attachments/assets/a38b990e-e69d-47f7-b4c4-fe92bc5d9d73)

  - 해시 특징:
    - 해시 함수 출력이 인덱스가 되기 때문에 값을 찾기 위한 탐색 과정이 필요 없음.
    - 찾고자 하는 값을 평균 시간복잡도 O(1)에서 찾을 수 있음.
    - 해시를 사용하지 않는다면, 모든 인덱스를 탐색하며 키의 위치를 찾아야 함.
      
  - 해시를 활용하는 분야:
    - 비밀번호 관리: 비밀번호를 그대로 노출해 저장하는 것은 위험하므로 해시 함수를 통해 해싱한 비밀번호를 저장함.
    - 데이터베이스 인덱싱: 저장된 데이터를 효율적으로 검색할 때 해시를 활용함.
    - 블록체인: 각 블록은 이전 블록의 해시값을 포함하고 있으며, 이를 통해 데이터 무결성을 확인함.
      
###  2. 해시 함수
  - 고려사항: 
    - 해시 함수가 반환하는 인덱스가 해시 테이블 크기를 넘으면 안됨.
    - 해시 함수의 변환된 출력에서 충돌이 최대한 적게 발생해야 함. 여기서 충돌이란 서로 다른 두 키에 대해 해시 함수의 출력이 같은 경우임.
      
  - 해시함수 종류: 
    - 나눗셈법 (division method)
      - $h(x) = x \ \text{mod} \ k$
      - x는 키이고 k는 소수 (prime number)임
      - 만약 소수를 사용하지 않으면, 충돌이 많이 발생함.
      - 테이블 크기는 K임. K가 소수일 때 나눗셈법의 출력은 0 ~ k-1이기 때문임.
    - 곱셈법 (multiplication method)
      - $h(x) = ((x*A) \ \text{mod} \ 1) *m$
      - x는 키이고 A는 황금비임. 황금비는 대략 1.6180339887...
      - 키에 황금비를 곱한 뒤, mod 1을 통해서 소수 부분만 취함.
      - 소수 부분에 테이블 크기 m을 곱한 뒤 결과 값에 소수 부분을 제거하여 정수 부분만 취하고 해시테이블 맵핑에 사용함.
      - 곱셈법은 황금비를 활용하므로 나눗셈법처럼 소수가 필요 없다는 장점이 있음.
    - 문자열 해싱
      - $h(s) = (s[0]+s[1]*p+s[2]*p^{2}... s[n-1]*p^{n-1}) \text {mod} \ m$
      - 키의 자료형이 문자열일 때 문자를 숫자로 변환하고 이 숫자들을 다항식의 값으로 변환해서 해싱함.
      - 위 식은 polynomial rolling method임.
      - p를 31, 해시 테이블 최대 크기는 m으로 설정할 수 있음. (31은 메르센 소수이면서 홀수임, 메르센 소수란 $2^{N}-1$로 표현이 가능한 소수를 의미함. 해시 충돌을 줄이는데 효과적임.)
      - polynomial rolling method를 사용할 때 주의점이 mod m을 적용하기 전에 함수 값이 너무 커서 오버플로우 문제가 발생할 수 있음.
      - $h(s) = (s[0]\mod m+s[1]*p+s[2]*p^{2}... s[n-1]*p^{n-1}) \text {mod} \ m$
      - 그래서 위 형태로 개선할 수 있음. 결과는 같음
        
###  3. 충돌 처리
  - 서로 다른 키에 대해서 해시 함수의 결괏값이 같으면 충돌 (collision)이라고 함.
    - 처리 방법:
      - 체이닝 (separate chaining)
        - 링크드리스트로 충돌한 데이터를 연결하는 방식으로 충돌을 해결함.
        - 장점:
          - 추가 저장을 통해 문제를 간단히 해결할 수 있음. 또한, 데이터 추가 및 삭제 과정이 간편함.
        - 단점:
          - 충돌이 많으면 링크드리스트 길이가 길어짐. 충돌이 자주 발생하는 곳에만 길이기 길어지기 때문에 해시 테이블의 전체적인 공간 활용도가 떨어질 수 있음.
          - 검색 성능이 떨어져서 속도가 느려질 수 있음. 예를 들어서 충돌이 발생했을 때 해당하는 키의 값을 찾기 위해서는 링크드리스트의 맨 앞에서부터 탐색해야 함.
     - 개방 주소법 (open addressing)
        - 링크드리스트나처럼 데이터를 추가로 저장하여 메모리를 사용하는 방식이 아니라 해시 테이블 내부에 비어있는 공간을 활용함.
        - 빈 공간을 찾기 위해 선형 탐사 (Linear probing), 이차 탐사 (quadratic probing), 이중 해싱 (double hashing probing) 방식 등이 있음
        - 장점:
          - 데이터 추가를 위한 메모리 사용이 필요 없음.
        - 단점:
          - 선형 탐사 방식의 경우 1칸씩 이동하며 빈 곳에 값을 넣기 때문에 특정 영역에 값들이 모이는 클러스터 (cluster) 문제가 있음. 클러스터가 생기면 겹칠 확률이 올라감.
          - 이를 개선하기 위해 제곱수만큼 이동하는 이차 탐사, 해시 함수를 두 개 사용하는 이중 해싱 방식들이 사용됨.
          - 또한, 데이터 삭제가 번거로운 이슈가 있음. 데이터 삭제 시 탐사 순서를 깰 수 있으며, 몇몇 데이터 접근을 어렵게 만들 수 있음.
          - Tombstone을 사용하여 탐사 순서를 유지할 수 있음. 또한, tombstone이 많아지면 공간 효율성과 탐사 길이가 길어지기 때문에 주기적으로 재해싱하는 작업이 필요할 수 있음.
    
